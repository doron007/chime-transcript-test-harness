// ==UserScript==
// @name         Chime Meeting Full Transcript Copier
// @namespace    @amzn/Chime-Meeting-Full-Transcript-Copier
// @version      2.9
// @license      UNLICENSED
// @namespace    http://tampermonkey.net/
// @description  Copies the full transcript of the meeting you have (copy during and after you close the call)
// @author       Doron Hetz (inspired by Christian Back Jonsson original script)
// @downloadURL  https://drive.corp.amazon.com/view/cjonsson@/Tampermonkey/ChimeMeetingFullTranscriptCopier.user.js
// @supportURL   https://w.amazon.com/bin/view/Users/cjonsson/ChimeMeetingFullTranscriptCopier/
// @match        https://app.chime.aws/meetings/*
// @grant        none
// @description  A comprehensive tool for capturing Amazon Chime meeting transcripts in real-time.
//
// @description:usage  HOW TO USE:
// @description:usage  1. Enable Closed Captions (CC) in your Chime meeting
// @description:usage  2. Script will automatically capture all CC text and chat messages
// @description:usage  3. Use 'Copy' button to copy to clipboard or 'Save' to download as file
//
// @description:features  FEATURES:
// @description:features  - Real-time CC capture with speaker attribution
// @description:features  - Chat message capture
// @description:features  - Attendee tracking
// @description:features  - Session resumption after browser refresh
// @description:features  - Automatic periodic saving
//
// @description:limitations  LIMITATIONS:
// @description:limitations  - Requires CC to be enabled
// @description:limitations  - Cannot capture messages from before script activation
// @description:limitations  - Browser-dependent functionality
// @description:limitations  - Limited formatting support for chat messages
//
// @description:planned  PLANNED FEATURES:
// @description:planned  - Transcript preview window
// @description:planned  - Multiple export formats
// @description:planned  - Meeting analytics
// @description:planned  - Search functionality
//
// @description:changes  CHANGELOG:
// @description:changes  v2.9 - Improved fuzzy matching algorithm for more accurate transcript capture
// @description:changes       - Added speaker segment merging for better readability
// @description:changes       - Fixed issues with sentence truncation and improved sentence boundary detection
// @description:changes  v2.8 - Bug fix for meeting ID
// @description:changes  v2.7 - Added keyboard shortcuts for comment injection (cmd+enter, esc)
// @description:changes       - Added content preview button with read-only view
// @description:changes  v2.6 - Fixed chat message capture for all formats and added fuzzy matching for CC corrections
// @description:changes       - Fixed chat message duplication issue
// @description:changes       - Added comment injection feature with input box
// @description:changes  v2.5 - Fixed sentence truncation issues
// @description:changes  v2.3 - Improved session resumption
// @description:changes  v2.2 - Added attendee tracking
// @description:changes  v2.1 - Added chat message capture
// @description:changes  v2.0 - Complete rewrite with IndexedDB storage
//
// ==/UserScript==

(function () {
  'use strict';

  const CONFIG = {
    DEBUG: false,
    DB: {
      NAME: 'ChimeTranscriptDB',
      VERSION: 3,
      STORE: 'sessions',
    },
    SELECTORS: {
      TRANSCRIPT: '._1bqBOFA5PPIrx5PUq9uxyl',
      CHAT_CONTAINER: '._2B9DdDvc2PdUbvEGXfOU20',
      MEETING_TITLE: '[data-testid="heading"]',
      MEETING_ID_REGION: '[data-test-id="meetingIdRegion"], [data-testid="meeting-id"]',
      MEETING_ORGANIZER: '[data-test-id="meetingOrganizerName"], [data-testid="meeting-organizer"]',
      SPEAKER: 'p._3512TwqLzPaGGAWp_8W1se',
      TEXT: 'p._1XM7bRv8y86tbk7HmDvoj7',
      CHAT_BUBBLE: '.chatBubbleContainer',
      CHAT_MESSAGE: '.chatMessage',
      CHAT_SENDER: '[data-testid="chat-bubble-sender-name"]',
      CHAT_TIMESTAMP: '.BSI7kBrZFl9kIe5WtRekW',
      CHAT_CONTENT: '.Linkify, .markdown p',
      ATTENDEES: {
        PRESENT_SECTION: 'button[aria-label*="Present"]',
        LEFT_SECTION: 'button[aria-label*="Left"]',
        SECTION_CONTAINER: '._1IEUbelvxVpEblfF0Mula8',
        NAME_ELEMENT: '.ppi5x8cvVEQgbl_hLeiRW',
      },
    },
    INTERVALS: {
      DB_SAVE: 10000,
      CAPTURE: 1000,
      TITLE_INIT: 2000,
      STATE_LOG: 5000, // Add this
      ATTENDEES_UPDATE: 30000, // Update attendees every 30 seconds
      SEGMENT_MERGE: 10000, // Merge segments every 10 seconds
    },
    STRINGS: {
      TITLE_PREFIX: 'Meeting Title: ',
      MEETING_DATE_PREFIX: 'Meeting Date: ',
      SYSTEM_MESSAGE:
        'Amazon Chime: Machine generated captions are generated by Amazon Transcribe.',
      SUBJECT_DEFAULT: 'Subject',
      CHAT_HEADER_CLASS: '_28K_fURZjQdxAmV_LRDwpp',
      ID_PATTERN: /(?:Meeting ID:|ID:)\s*([0-9\s]+)/,
      ORGANIZER_PATTERN: /(?:Organizer:|Organized by:)\s*(.*)/,
      ATTENDEES_PREFIX: 'Attendees: ',
      ATTENDEES_SEPARATOR: ', ',
    },
    MEETING: {
      RESUME_WINDOW: 600000,
      CHECK_DELAY: 2000,
      MAX_RETRIES: 10,
      RETRY_DELAY: 2000,
    },
    MESSAGES: {
      SYSTEM_CAPTION: 'Machine generated captions',
      SYSTEM_SENDER: 'Amazon Chime',
      NO_CONTENT: 'Nothing to copy. Please turn on CC Transcript.',
      COPY_SUCCESS: 'Full Transcript copied to clipboard!',
      SAVE_SUCCESS: 'Transcript saved to file!',
    },
    FILE: {
      TYPE: 'text/plain',
      SUFFIX: 'MoM',
    },
    TIMINGS: {
      STATE_LOG_INTERVAL: 5000,
      SNACKBAR_DURATION: 3000,
    },
    REGEX: {
      CHAT_TIMESTAMP: /\[\d{1,2}:\d{2}\s[AP]M\]/,
      LINKIFY_CLASS: '.Linkify',
    },
    FUZZY_MATCH: {
      MIN_LENGTH: 15, // Minimum length for reliable word-based matching
      INITIAL_PORTION: 0.4, // Proportion of words to check for initial similarity
      SIMILARITY_THRESHOLD: 0.7, // Overall similarity threshold
      MIN_COMMON_WORDS: 4, // Minimum number of common words to consider similar
      SHORT_MATCH_THRESHOLD: 0.8, // Similarity threshold for short entries
    },
    MERGE: {
      TIME_THRESHOLD: 20, // Maximum time difference in seconds to consider merging
      MIN_LENGTH: 15, // Minimum length to consider for relatedness determination
      CONTINUATION_THRESHOLD: 0.4, // Minimum similarity for entries to be considered related
    },
    UI: {
      COPY_BUTTON: {
        TEXT: 'Copy',
        COLOR: '#4CAF50',
        STYLES: {
          position: 'fixed',
          bottom: '10px',
          right: '10px',
          width: '70px',
          height: '38px',
          padding: '0',
        },
      },
      SAVE_BUTTON: {
        TEXT: 'Save',
        COLOR: '#007BFF',
        STYLES: {
          position: 'fixed',
          bottom: '10px',
          right: '80px',
          width: '70px',
          height: '38px',
          padding: '0',
        },
      },
      COMMENT_BUTTON: {
        TEXT: '+',
        COLOR: '#FFA500',
        STYLES: {
          position: 'fixed',
          bottom: '10px',
          right: '150px',
          width: '40px',
          height: '38px',
          padding: '0',
          fontSize: '24px',
        },
      },
      VIEW_BUTTON: {
        TEXT: '^',
        COLOR: '#808080',
        STYLES: {
          position: 'fixed',
          bottom: '10px',
          right: '190px',
          width: '40px',
          height: '38px',
          padding: '0',
          fontSize: '24px',
        },
      },
      COMMENT_CONTAINER: {
        STYLES: {
          position: 'fixed',
          right: '50px',
          bottom: '210px',
          backgroundColor: '#333',
          padding: '10px',
          borderRadius: '4px',
          boxShadow: '0 2px 10px rgba(0,0,0,0.3)',
          zIndex: '10000',
          gap: '8px',
          alignItems: 'flex-end',
          width: 'auto', // Allow container to adjust to content
          maxWidth: '800px', // 1.5x the original width
        },
      },
      COMMENT_INPUT: {
        STYLES: {
          width: '600px', // 1.5x the original width
          height: '120px',
          backgroundColor: '#333',
          color: '#fff',
          border: '1px solid #666',
          resize: 'none',
          padding: '10px',
          borderRadius: '4px',
          fontSize: '14px',
          fontFamily: 'monospace', // Better for viewing formatted content
          whiteSpace: 'pre', // Preserve line breaks
          overflowX: 'auto', // Enable horizontal scroll
          overflowY: 'auto', // Enable vertical scroll
        },
      },
      SUBMIT_BUTTON: {
        TEXT: '>',
        COLOR: '#4CAF50',
        STYLES: {
          position: 'absolute',
          right: '15px', // Match original
          bottom: '15px', // Match original
          width: '20px',
          height: '20px',
          borderRadius: '10px',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          fontWeight: 'bold',
          fontSize: '16px', // Match original
        },
      },
      CLOSE_BUTTON: {
        TEXT: '×',
        STYLES: {
          position: 'absolute',
          right: '15px',
          top: '15px',
          width: '20px',
          height: '20px',
          backgroundColor: 'transparent',
          color: '#fff',
          border: 'none',
          cursor: 'pointer',
          fontSize: '16px',
          lineHeight: '16px',
          padding: '0',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: '10000',
        },
      },
      COMMON: {
        BUTTON: {
          color: 'white',
          border: 'none',
          borderRadius: '4px',
          cursor: 'pointer',
          zIndex: '9999',
          padding: '10px 20px', // Add this to match original
          fontSize: '16px', // Add this to match original
        },
      },
      MERGE_TOGGLE: {
        TEXT_ON: 'Merge: ON',
        TEXT_OFF: 'Merge: OFF',
        COLOR_ON: '#9C27B0',
        COLOR_OFF: '#777777',
        STYLES: {
          position: 'fixed',
          bottom: '10px',
          right: '230px',
          width: '95px',
          height: '38px',
          padding: '0',
        },
      },
    },
    CACHE: {
      KEY: 'chime_transcript_cache',
      UPDATE_INTERVAL: 60000, // 1 minute
      MAX_AGE: 24 * 60 * 60 * 1000, // 24 hours
    },
    SESSION: {
      RESUME_THRESHOLD: 5 * 60 * 1000, // 5 minutes in milliseconds
    },
    STYLES: {
      SNACKBAR: {
        position: 'fixed',
        bottom: '30px',
        left: '50%',
        transform: 'translateX(-50%)',
        backgroundColor: '#333',
        color: '#fff',
        padding: '12px 20px',
        borderRadius: '5px',
        fontSize: '14px',
        textAlign: 'center',
        zIndex: '10000',
        visibility: 'hidden',
        opacity: '0',
        transition: 'visibility 0s, opacity 0.5s ease-in-out',
      },
    },
  };

  let transcriptManager, uiManager, dbManager, cacheManager;

  const Utils = {
    sanitizeFilename: (text) => {
      return text
        .replace(/[<>:"\/\\|?*,]/g, '-')
        .replace(/\s+/g, ' ')
        .replace(/\s*\|\s*/g, '-')
        .replace(/--+/g, '-')
        .replace(/^-|-$/g, '')
        .trim()
        .substring(0, 200);
    },

    formatSpeakerName: (speaker) => {
      const parts = speaker.split(', ');
      return parts.length === 2 ? `${parts[1]} ${parts[0]}` : speaker;
    },

    createElement: (type, props = {}) => {
      const element = document.createElement(type);
      Object.entries(props).forEach(([key, value]) => {
        if (key === 'style') {
          Object.assign(element.style, value);
        } else {
          element[key] = value;
        }
      });
      return element;
    },

    getPSTDateTime: () => {
      const now = new Date();
      const pstDate = now
        .toLocaleDateString('en-CA', { timeZone: 'America/Los_Angeles' })
        .substring(5);
      const pstTime = now
        .toLocaleTimeString('en-US', { timeZone: 'America/Los_Angeles', hour12: true })
        .split(':');
      const formattedTime = `${pstTime[0]}-${pstTime[1]} ${pstTime[2].split(' ')[1]}`;
      return { date: pstDate, time: formattedTime };
    },

    fuzzyMatch: (str1, str2) => {
      // Normalize strings - remove punctuation and standardize spacing
      const normalize = (str) =>
        str
          .toLowerCase()
          .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '')
          .replace(/\s+/g, ' ')
          .trim();

      const norm1 = normalize(str1);
      const norm2 = normalize(str2);

      // Direct match
      if (norm1 === norm2) {
        return true;
      }

      // Check if normalized version starts with the other
      if (norm1.startsWith(norm2) || norm2.startsWith(norm1)) {
        return true;
      }

      // For longer texts, check parts and word similarity
      if (norm1.length > 10 && norm2.length > 10) {
        // Check for substantial overlapping content
        const minLength = Math.min(norm1.length, norm2.length);
        const comparisonLength = Math.max(minLength - 5, 10);

        const str1Core = norm1.substring(0, comparisonLength);
        const str2Core = norm2.substring(0, comparisonLength);

        // If the core texts match or contain each other
        if (str1Core === str2Core || norm1.includes(str2Core) || norm2.includes(str1Core)) {
          return true;
        }
      }

      return false;
    },
  };

  const Logger = {
    debug: (message, ...args) => {
      if (CONFIG.DEBUG) console.log(message, ...args);
    },
    info: (message, ...args) => {
      console.log(message, ...args);
    },
    warn: (message, ...args) => {
      // Add this method
      console.warn(message, ...args);
    },
    error: (message, ...args) => {
      console.error(message, ...args);
    },
  };

  class CacheManager {
    constructor() {
      this.lastUpdate = 0;
    }

    saveToCache(content) {
      const now = Date.now();
      if (now - this.lastUpdate >= CONFIG.CACHE.UPDATE_INTERVAL) {
        try {
          const cacheData = {
            content,
            timestamp: now,
          };
          localStorage.setItem(CONFIG.CACHE.KEY, JSON.stringify(cacheData));
          this.lastUpdate = now;
        } catch (error) {
          Logger.error('Cache save failed:', error);
        }
      }
    }

    loadFromCache() {
      try {
        const cached = localStorage.getItem(CONFIG.CACHE.KEY);
        if (!cached) return null;

        const data = JSON.parse(cached);
        const age = Date.now() - data.timestamp;

        if (age > CONFIG.CACHE.MAX_AGE) {
          localStorage.removeItem(CONFIG.CACHE.KEY);
          return null;
        }

        return data.content;
      } catch (error) {
        Logger.error('Cache load failed:', error);
        return null;
      }
    }

    clearCache() {
      localStorage.removeItem(CONFIG.CACHE.KEY);
    }
  }

  class TranscriptManager {
    constructor() {
      this.history = [];
      this.processedMessages = new Set();
      this.lastSender = null;
      this.lastTimestamp = null;
      this.meetingId = null;
      this.meetingTitle = CONFIG.STRINGS.SUBJECT_DEFAULT;
      this.meetingOrganizer = null;
      this.isResumed = false;
      this.isResuming = false;
      this.hasTitleBeenAdded = false;
      this.systemMessageAdded = false;
      this.sessionId = null;
      this.meetingDetailsLoaded = false;
      this.detailsRetryCount = 0;
      this.captureStarted = false;
      this.lastAttendeesUpdate = '';
      this.currentAttendees = '';
      this.attendeesUpdateInterval = null;

      if (CONFIG.DEBUG) {
        setInterval(() => this.logState('periodic'), CONFIG.INTERVALS.STATE_LOG);
      }
    }

    initialize(uiManager) {
      this.uiManager = uiManager;
      cacheManager.clearCache();
      window.addEventListener('beforeunload', () => {
        try {
          // Final save attempts
          if (this.history.length > 0) {
            cacheManager.saveToCache(this.getContent());
            dbManager.saveSession().catch((err) => Logger.error('Final save failed:', err));
          }

          // Cleanup
          if (this.transcriptObserver) this.transcriptObserver.disconnect();
          if (this.chatObserver) this.chatObserver.disconnect();
        } catch (error) {
          Logger.error('Cleanup error:', error);
        }
      });
      this.checkCCEnabled();
      // this.setupContentObservers();
      this.setupHealthCheck();
      this.setupMemoryManagement();
      this.enableErrorRecoveryMode();
      this.startAttendeesTracking();
    }

    async attemptContentRecovery() {
      // First try IndexedDB
      if (dbManager.ready) {
        try {
          const session = await dbManager.getLastSession();
          if (session && session.content) {
            Logger.info('Recovered content from IndexedDB');
            return session.content;
          }
        } catch (error) {
          Logger.error('IndexedDB recovery failed:', error);
        }
      }

      // If IndexedDB fails or no content, try cache
      try {
        const cachedContent = cacheManager.loadFromCache();
        if (cachedContent) {
          Logger.info('Recovered content from cache');
          return cachedContent;
        }
      } catch (error) {
        Logger.error('Cache recovery failed:', error);
      }

      return null;
    }

    initializeMeetingTitle() {
      const titleElement = document.querySelector(CONFIG.SELECTORS.MEETING_TITLE);
      this.meetingTitle = titleElement
        ? titleElement.textContent.trim()
        : CONFIG.STRINGS.SUBJECT_DEFAULT;
      return this.meetingTitle;
    }

    addEntry(entry) {
      if (!this.history.includes(entry)) {
        this.history.push(entry);
        Logger.debug('Added new entry:', entry);
        return true;
      }
      return false;
    }

    getMeetingDetails() {
      if (this.meetingDetailsLoaded && this.meetingId && this.meetingOrganizer) {
        return true;
      }

      if (this.detailsRetryCount === 0) {
        Logger.info('Attempting to get meeting details...');
      }
      this.detailsRetryCount++;

      try {
        let missingDetails = [];
        let detailsStatus = {
          meetingId: false,
          meetingTitle: false,
          organizer: false,
        };

        // Get meeting ID
        const waitForMeetingStart = (retryCount = 0) => {
          const modal = document.querySelector('[data-testid="modal-body"]'); // Detect if join modal is open
          const idElement = document.querySelector(CONFIG.SELECTORS.MEETING_ID_REGION);

          if (modal) {
            Logger.info('Waiting for user to join meeting... Attempt:', retryCount + 1);
            if (retryCount < 15) {
              // Retry for up to 15 seconds
              setTimeout(() => waitForMeetingStart(retryCount + 1), 1000);
            } else {
              Logger.error('Timeout: Meeting was not joined within expected time.');
            }
            return;
          }

          // Get meeting ID only after modal is gone
          if (!this.meetingId && idElement) {
            const idMatch = idElement.textContent.match(CONFIG.STRINGS.ID_PATTERN);
            if (idMatch) {
              this.meetingId = idMatch[1].replace(/\s/g, '');
              detailsStatus.meetingId = true;
              Logger.info('Found meeting ID:', this.meetingId);
            } else {
              Logger.error('Meeting ID format mismatch. Text content:', idElement.textContent);
              missingDetails.push('Meeting ID format invalid');
            }
          } else if (!this.meetingId) {
            Logger.error('Meeting ID element not found. Retrying...');
            if (retryCount < 15) {
              setTimeout(() => waitForMeetingStart(retryCount + 1), 1000);
            } else {
              Logger.error('Timeout: Meeting ID was not found.');
            }
          } else {
            detailsStatus.meetingId = true;
          }
        };

        // Start waiting for meeting to begin
        waitForMeetingStart();

        // Get meeting title
        if (!this.meetingTitle || this.meetingTitle === CONFIG.STRINGS.SUBJECT_DEFAULT) {
          const titleElement = document.querySelector(CONFIG.SELECTORS.MEETING_TITLE);
          if (titleElement) {
            this.meetingTitle = titleElement.textContent.trim();
            detailsStatus.meetingTitle = true;
            Logger.info('Found meeting title:', this.meetingTitle);
          } else {
            Logger.error(
              'Meeting title element not found. Selector:',
              CONFIG.SELECTORS.MEETING_TITLE
            );
            missingDetails.push('Meeting title element not found');
            // Recovery: Use default title
            this.meetingTitle = 'Meeting';
            Logger.info('Using default meeting title');
            detailsStatus.meetingTitle = true;
          }
        } else {
          detailsStatus.meetingTitle = true;
        }

        // Get organizer
        if (!this.meetingOrganizer) {
          const organizerElement = document.querySelector(CONFIG.SELECTORS.MEETING_ORGANIZER);
          if (organizerElement) {
            const organizerMatch = organizerElement.textContent.match(
              CONFIG.STRINGS.ORGANIZER_PATTERN
            );
            if (organizerMatch) {
              this.meetingOrganizer = organizerMatch[1].trim();
              detailsStatus.organizer = true;
              Logger.info('Found meeting organizer:', this.meetingOrganizer);
            } else {
              Logger.error(
                'Organizer format mismatch. Text content:',
                organizerElement.textContent
              );
              missingDetails.push('Organizer format invalid');
            }
          } else {
            Logger.error(
              'Organizer element not found. Selector:',
              CONFIG.SELECTORS.MEETING_ORGANIZER
            );
            missingDetails.push('Organizer element not found');
            // Recovery: Use default organizer
            this.meetingOrganizer = 'Organizer';
            Logger.info('Using default organizer');
            detailsStatus.organizer = true;
          }
        } else {
          detailsStatus.organizer = true;
        }

        // Log page structure for debugging if any details are missing
        if (missingDetails.length > 0) {
          Logger.debug('Current page structure:', {
            meetingIdArea: document.querySelector('[data-testid*="meeting"]')?.outerHTML,
            titleArea: document.querySelector('[data-testid*="heading"]')?.outerHTML,
            organizerArea: document.querySelector('[data-testid*="organizer"]')?.outerHTML,
          });
        }

        // Log detailed status on each attempt
        Logger.info('Meeting details status:', {
          attempt: this.detailsRetryCount,
          status: detailsStatus,
          missing: missingDetails,
          final: {
            meetingId: this.meetingId,
            meetingTitle: this.meetingTitle,
            organizer: this.meetingOrganizer,
          },
        });

        // Always consider details loaded since we have fallbacks for everything
        this.meetingDetailsLoaded = true;

        if (this.detailsRetryCount > 1) {
          Logger.info(
            'Completed meeting details loading after',
            this.detailsRetryCount,
            'attempts',
            {
              meetingId: this.meetingId,
              meetingTitle: this.meetingTitle,
              organizer: this.meetingOrganizer,
              usedFallbacks: missingDetails.length > 0,
            }
          );
        }

        return true; // Always return true since we have fallbacks
      } catch (error) {
        Logger.error('Error getting meeting details:', {
          error,
          attempt: this.detailsRetryCount,
          stack: error.stack,
        });

        // Apply fallbacks even in case of error
        if (!this.meetingId) {
          const timestamp = new Date().toISOString().replace(/[-:]/g, '').split('.')[0];
          this.meetingId = `session_${timestamp}`;
        }
        if (!this.meetingTitle) {
          this.meetingTitle = 'Meeting';
        }
        if (!this.meetingOrganizer) {
          this.meetingOrganizer = 'Organizer';
        }

        this.meetingDetailsLoaded = true;
        return true; // Return true since we have fallbacks
      }
    }

    async checkForResume() {
      if (!this.meetingDetailsLoaded) {
        const success = await this.waitForMeetingDetails();
        if (!success) {
          Logger.info('Resume check failed: Could not get meeting details');
          return false;
        }
      }

      Logger.info('Getting last session for meeting ID:', this.meetingId);

      try {
        const now = Date.now();

        const allSessions = await dbManager.getAllSessions();
        const matchingSession = allSessions
          .filter(
            (session) =>
              session.meetingId === this.meetingId && // Ensure it's the same meeting
              session.meetingTitle === this.meetingTitle && // Ensure the title matches
              now - (session.lastUpdated || session.timestamp) < CONFIG.SESSION.RESUME_THRESHOLD // Ensure session is recent
          )
          .sort((a, b) => (b.lastUpdated || b.timestamp) - (a.lastUpdated || a.timestamp)) // Get the most recent session
          .find((session) => session.content && session.content.trim().length > 0); // Ensure session has meaningful content

        if (matchingSession) {
          const lastUpdateTime = matchingSession.lastUpdated || matchingSession.timestamp;
          const timeDiff = now - lastUpdateTime;

          Logger.info('Found matching session:', {
            id: matchingSession.id,
            meetingId: matchingSession.meetingId,
            meetingTitle: matchingSession.meetingTitle,
            contentLines: matchingSession.content?.split('\n').length || 0,
            lastUpdated: new Date(lastUpdateTime).toLocaleString(),
            timeSinceUpdate: Math.floor(timeDiff / 1000 / 60) + ' minutes',
          });

          this.isResuming = true;
          const success = await this.resumeSession(matchingSession);
          this.isResuming = false;
          if (success) {
            Logger.info('Successfully resumed session from IndexedDB');
            return true;
          }
        } else {
          Logger.info('No valid session found to resume');
          return false;
        }

        // If no valid session found in IndexedDB, try cache recovery
        const recoveredContent = await this.attemptContentRecovery();
        if (recoveredContent) {
          this.isResuming = true;
          const success = await this.resumeSession({
            id: this.getSessionId(),
            content: recoveredContent,
            timestamp: now,
            lastUpdated: now,
          });
          this.isResuming = false;
          if (success) {
            Logger.info('Successfully resumed session from cache');
            return true;
          }
        }

        Logger.info('No valid session found to resume');
        return false;
      } catch (error) {
        Logger.error('Error during resume process:', error);
        this.isResuming = false;
        return false;
      }
    }

    async resumeSession(session) {
      if (!session || !session.content) {
        Logger.info('Invalid session data for resume');
        return false;
      }

      this.isResuming = true; // Set flag before starting resume
      Logger.info('Starting session resume...');

      try {
        // Reset state
        this.history = [];
        this.processedMessages.clear();
        this.hasTitleBeenAdded = false;
        this.systemMessageAdded = false;

        // Process saved content
        const savedLines = session.content.split('\n');
        Logger.info(`Restoring ${savedLines.length} lines from saved session`);

        savedLines.forEach((line) => {
          if (!line.trim()) return;

          // Process line based on content type
          if (line.startsWith(CONFIG.STRINGS.TITLE_PREFIX)) {
            this.hasTitleBeenAdded = true;
          } else if (line.includes(CONFIG.MESSAGES.SYSTEM_CAPTION)) {
            this.systemMessageAdded = true;
          }

          // Add to history
          this.history.push(line);

          // Track chat messages
          if (line.match(CONFIG.REGEX.CHAT_TIMESTAMP)) {
            this.processedMessages.add(line);
          }
        });

        this.sessionId = session.id;
        this.isResumed = true;

        Logger.info('Resume completed successfully:', {
          totalLines: this.history.length,
          processedMessages: this.processedMessages.size,
          hasTitleBeenAdded: this.hasTitleBeenAdded,
          systemMessageAdded: this.systemMessageAdded,
        });

        return true;
      } catch (error) {
        Logger.error('Error during resume:', error);
        return false;
      } finally {
        this.isResuming = false; // Clear flag when done
      }
    }

    logState(type = 'periodic') {
      if (!CONFIG.DEBUG && type === 'periodic') return;

      const state = {
        historyLength: this.history.length,
        processedMessages: this.processedMessages.size,
        hasTitleBeenAdded: this.hasTitleBeenAdded,
        systemMessageAdded: this.systemMessageAdded,
        isResumed: this.isResumed,
        meetingId: this.meetingId,
        meetingTitle: this.meetingTitle,
      };

      Logger.debug(`${type === 'periodic' ? 'Current' : 'Session'} State:`, state);
    }

    formatMeetingDate() {
      const today = new Date();
      const month = String(today.getMonth() + 1).padStart(2, '0');
      const day = String(today.getDate()).padStart(2, '0');
      return {
        titleFormat: `[${month}-${day}]`,
        dateFormat: `${month}/${day}`,
      };
    }

    captureLastRow() {
      const transcriptElement = document.querySelector(CONFIG.SELECTORS.TRANSCRIPT);
      if (!transcriptElement) {
        Logger.error('Transcript element not found, will retry');
        return;
      }

      if (!this.hasTitleBeenAdded && this.history.length === 0) {
        const currentTitle = this.initializeMeetingTitle();
        const { titleFormat, dateFormat } = this.formatMeetingDate();
        this.addEntry(
          `${CONFIG.STRINGS.TITLE_PREFIX}${titleFormat} - ${currentTitle}\n${CONFIG.STRINGS.MEETING_DATE_PREFIX}${dateFormat}`
        );
        this.hasTitleBeenAdded = true;
      }
      this.updateAttendeesList();

      const speakerElements = transcriptElement.querySelectorAll(CONFIG.SELECTORS.SPEAKER);
      const textElements = transcriptElement.querySelectorAll(CONFIG.SELECTORS.TEXT);

      if (speakerElements.length > 0 && textElements.length > 0) {
        const lastSpeakerIndex = speakerElements.length - 1;
        const lastTextIndex = textElements.length - 1;
        let speaker = speakerElements[lastSpeakerIndex].textContent;
        const text = textElements[lastTextIndex].textContent;

        Logger.debug('CC Capture - Raw:', { speaker, text, historyLength: this.history.length });

        // Handle system message
        if (
          speaker === CONFIG.MESSAGES.SYSTEM_SENDER &&
          text.includes(CONFIG.MESSAGES.SYSTEM_CAPTION)
        ) {
          if (!this.systemMessageAdded) {
            this.systemMessageAdded = true;
            this.addEntry(CONFIG.STRINGS.SYSTEM_MESSAGE);
          }
          return;
        }

        // Format speaker name
        speaker = Utils.formatSpeakerName(speaker);
        // Get current time in required format
        const time = new Date().toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true,
        });
        // const formattedLine = `${speaker}: ${text}`.trim();
        const formattedLine = `${speaker} [${time}]: ${text}`.trim();

        // Get the last history entry
        let lastCCEntry = null;
        for (let i = this.history.length - 1; i >= 0; i--) {
          //if (!this.history[i].startsWith('[') && this.history[i].startsWith(`${speaker}:`)) {
          if (!this.history[i].startsWith('[')) {
            lastCCEntry = this.history[i];
            break;
          }
        }

        if (!lastCCEntry) {
          this.addEntry(formattedLine);
          Logger.debug('Added new line for different speaker:', formattedLine);
          return;
        }

        // Get just the text portion of the last CC entry
        const lastEntryText = lastCCEntry.substring(lastCCEntry.indexOf(']: ') + 3).trim();
        //const lastEntryText = lastCCEntry.replace(/^[^:]+]:\s*/, '').trim();
        const currentText = text.trim();

        // Add this log line:
        Logger.debug('CC Capture - Text Compare:', {
          lastEntryText,
          currentText,
          lastIncludes: lastEntryText.includes(currentText),
          currentIncludes: currentText.includes(lastEntryText),
          lengths: { last: lastEntryText.length, current: currentText.length },
        });

        if (lastEntryText === currentText) {
          // Check if the timestamp difference is very small (avoid treating as new)
          const lastTimestamp = lastCCEntry.match(/\[(\d{1,2}:\d{2}\s[AP]M)\]/);
          const currentTimestamp = time;
          if (lastTimestamp && currentTimestamp && lastTimestamp[0] === currentTimestamp) {
            return; // Skip duplicate
          }
        }

        if (currentText.startsWith(lastEntryText)) {
          // If the new text is an extension, update last entry
          const lastCCIndex = this.history.lastIndexOf(lastCCEntry);
          this.history[lastCCIndex] = formattedLine;
          Logger.debug('Updated existing line:', { old: lastCCEntry, new: formattedLine });
        } else {
          // If not an extension, treat as a new entry
          this.addEntry(formattedLine);
          Logger.debug('Added new line for new sentence:', formattedLine);
        }

        /*                // If the current text is completely different from the last entry's text,
                // treat it as a new sentence
                if (!lastEntryText.includes(currentText) && !currentText.includes(lastEntryText)) {
                    this.addEntry(formattedLine);
                    Logger.debug('Added new line for new sentence:', formattedLine);
                } else if (currentText.length > lastEntryText.length) {
                    // Only update if the current text is longer (continuing sentence)
                    const lastCCIndex = this.history.lastIndexOf(lastCCEntry);
                    this.history[lastCCIndex] = formattedLine;
                    Logger.debug('Updated existing line:', {
                        old: lastCCEntry,
                        new: formattedLine
                    });
                } */
      }
    }

    captureChatMessage(container) {
      const messageElement = container.querySelector(CONFIG.SELECTORS.CHAT_MESSAGE);
      if (!messageElement) return null;

      // Get sender name and timestamp from header
      const headerDiv = messageElement.querySelector(`.${CONFIG.STRINGS.CHAT_HEADER_CLASS}`);
      if (headerDiv) {
        const senderElement = headerDiv.querySelector(CONFIG.SELECTORS.CHAT_SENDER);
        const timeElement = headerDiv.querySelector(CONFIG.SELECTORS.CHAT_TIMESTAMP);
        if (senderElement && timeElement) {
          if (senderElement.textContent === CONFIG.MESSAGES.SYSTEM_SENDER) {
            const messageContent = messageElement.querySelector(CONFIG.SELECTORS.CHAT_CONTENT);
            if (
              messageContent &&
              messageContent.textContent.includes('Machine generated captions')
            ) {
              return null;
            }
          }

          this.lastSender = senderElement.textContent;
          this.lastTimestamp = timeElement.textContent;
        }
      }

      // Get message content - handling both formats but avoiding duplicates
      const contentElements = messageElement.querySelectorAll(CONFIG.SELECTORS.CHAT_CONTENT);
      if (!contentElements.length) return null;

      // Get unique content
      const message = Array.from(contentElements)
        .map((el) => el.textContent.trim())
        .filter((text) => text) // Remove empty strings
        .reduce((unique, text) => unique || text, ''); // Take first non-empty text

      // Skip empty messages
      if (!message || !this.lastSender || !this.lastTimestamp) return null;

      // Create message identifier
      const messageId = `[${this.lastTimestamp}] - ${this.lastSender}: ${message}`;

      // Check if already processed
      if (this.processedMessages.has(messageId)) {
        return null;
      }

      // Add to processed messages
      this.processedMessages.add(messageId);

      return messageId;
    }

    captureNewChatMessages() {
      const chatContainer = document.querySelector(CONFIG.SELECTORS.CHAT_CONTAINER);
      if (!chatContainer) return;

      const chatBubbles = Array.from(chatContainer.querySelectorAll(CONFIG.SELECTORS.CHAT_BUBBLE));

      // Process bubbles in order
      chatBubbles.forEach((bubble) => {
        const messageContent = this.captureChatMessage(bubble);
        if (messageContent && !this.history.includes(messageContent)) {
          this.addEntry(messageContent);
        }
      });
    }

    getRawContent() {
      const titleIndex = this.history.findIndex((line) =>
        line.startsWith(CONFIG.STRINGS.TITLE_PREFIX)
      );

      if (titleIndex === -1) {
        return this.history.join('\n');
      }

      // Create a copy of history
      const content = [...this.history];

      // Insert attendees after title if we have them
      if (this.currentAttendees) {
        const attendeesLine = `${CONFIG.STRINGS.ATTENDEES_PREFIX}${this.currentAttendees}\n`;
        content.splice(titleIndex + 1, 0, attendeesLine);
      }

      return content.join('\n');
    }

    getContent(applyFuzzyMatch = false) {
      const rawContent = this.getRawContent();
      return applyFuzzyMatch ? this.cleanupDuplicateLines(rawContent) : rawContent;
    }

    getSessionId() {
      // If we already have a session ID, return it
      if (this.sessionId) {
        return this.sessionId;
      }

      // For IndexedDB, include both date and meetingId to differentiate meetings
      const { date } = Utils.getPSTDateTime();
      const sanitizedTitle = Utils.sanitizeFilename(this.meetingTitle);

      // Include meetingId in the session ID for uniqueness
      this.sessionId = `[${date}] - ${sanitizedTitle} - MoM - ${this.meetingId}`;
      return this.sessionId;
    }

    // Add a new method to get filename (without meetingId)
    getFileNameId() {
      const { date } = Utils.getPSTDateTime();
      const sanitizedTitle = Utils.sanitizeFilename(this.meetingTitle);
      return `[${date}] - ${sanitizedTitle} - MoM`;
    }

    async waitForMeetingDetails() {
      return new Promise((resolve) => {
        const checkDetails = () => {
          if (this.getMeetingDetails()) {
            resolve(true);
          } else if (this.detailsRetryCount < CONFIG.MEETING.MAX_RETRIES) {
            setTimeout(checkDetails, CONFIG.MEETING.RETRY_DELAY);
          } else {
            resolve(false);
          }
        };
        checkDetails();
      });
    }

    getMessageTimestamp(message) {
      try {
        const timestampMatch = message.match(/\[(.*?)\]/);
        if (timestampMatch) {
          const timeStr = timestampMatch[1];
          const today = new Date();
          const [hours, minutes, period] = timeStr.split(/[:|\s]/);

          let hour = parseInt(hours);
          if (period === 'PM' && hour < 12) hour += 12;
          if (period === 'AM' && hour === 12) hour = 0;

          today.setHours(hour, parseInt(minutes), 0, 0);
          return today.getTime();
        }
      } catch (error) {
        Logger.error('Error parsing message timestamp:', error);
      }
      return Date.now(); // Fallback to current time
    }

    checkCCEnabled() {
      let ccCheck = 0;
      const ccCheckInterval = setInterval(() => {
        ccCheck++;
        const transcriptElement = document.querySelector(CONFIG.SELECTORS.TRANSCRIPT);
        if (!transcriptElement && ccCheck < 5) {
          Logger.warn('CC might not be enabled, attempt:', ccCheck);
          // Show visual warning to user
          uiManager.showSnackbar('Please enable Closed Captions (CC) to capture transcript', true);
        } else if (ccCheck >= 5) {
          clearInterval(ccCheckInterval);
        }
      }, 5000); // Check every 5 seconds initially
    }

    setupContentObservers() {
      // Store observers as class properties for cleanup
      if (this.transcriptObserver) this.transcriptObserver.disconnect();
      if (this.chatObserver) this.chatObserver.disconnect();

      this.transcriptObserver = new MutationObserver((mutations) => {
        try {
          Logger.debug('Transcript mutation:', {
            mutations: mutations.map((m) => ({
              type: m.type,
              targetType: m.target?.nodeType,
              targetClass: m.target?.className,
              addedNodes: m.addedNodes?.length || 0,
            })),
          });

          // Check if any mutation actually changed content
          const hasContentChange = mutations.some(
            (mutation) =>
              mutation.type === 'childList' ||
              mutation.type === 'characterData' ||
              mutation.addedNodes.length > 0
          );

          if (hasContentChange) {
            this.captureLastRow();
          }
        } catch (error) {
          Logger.error('Error in transcript observer:', error);
        }
      });

      this.chatObserver = new MutationObserver((mutations) => {
        try {
          this.captureNewChatMessages();
        } catch (error) {
          Logger.error('Error in chat observer:', error);
        }
      });

      // Setup observers with retry
      const setupObservers = () => {
        const transcriptElement = document.querySelector(CONFIG.SELECTORS.TRANSCRIPT);
        const chatElement = document.querySelector(CONFIG.SELECTORS.CHAT_CONTAINER);

        if (transcriptElement) {
          this.transcriptObserver.observe(transcriptElement, {
            childList: true,
            subtree: true,
            characterData: true,
          });
          Logger.info('Transcript observer attached');
        }

        if (chatElement) {
          this.chatObserver.observe(chatElement, {
            childList: true,
            subtree: true,
          });
        }

        if (!transcriptElement || !chatElement) {
          setTimeout(setupObservers, 1000);
        }
      };

      setupObservers();
    }

    setupHealthCheck() {
      let lastCaptureCount = 0;
      let staleCount = 0;

      setInterval(() => {
        const currentCount = this.history.length;
        const transcriptElement = document.querySelector(CONFIG.SELECTORS.TRANSCRIPT);
        const ccEnabled = !!transcriptElement;

        if (currentCount === lastCaptureCount) {
          staleCount++;
          if (staleCount >= 5 && ccEnabled) {
            // Increased threshold and only if CC is enabled
            Logger.warn('Possible capture stall detected');

            // Only reinitialize observers, don't force capture
            this.setupContentObservers();

            // Only show warning if really needed
            if (staleCount >= 10) {
              uiManager.showSnackbar('Reinitializing capture...', true);
            }
          }
        } else {
          staleCount = 0;
        }

        lastCaptureCount = currentCount;
      }, 20000); // Increased interval to 20 seconds
    }

    setupMemoryManagement() {
      setInterval(
        () => {
          try {
            // Clean up processed messages set periodically
            const oldestTimestamp = Date.now() - 60 * 60 * 1000; // 1 hour
            this.processedMessages.forEach((message) => {
              if (this.getMessageTimestamp(message) < oldestTimestamp) {
                this.processedMessages.delete(message);
              }
            });

            // Force garbage collection of removed references
            if (window.gc) {
              window.gc();
            }
          } catch (error) {
            Logger.error('Error in memory management:', error);
          }
        },
        30 * 60 * 1000
      ); // Run every 30 minutes
    }

    enableErrorRecoveryMode() {
      window.onerror = (msg, url, lineNo, columnNo, error) => {
        Logger.error('Global error:', { msg, url, lineNo, columnNo, error });

        // Attempt to save current state
        if (this.history.length > 0) {
          cacheManager.saveToCache(this.getContent());
          dbManager.saveSession().catch((err) => Logger.error('Emergency save failed:', err));
        }

        return false; // Allow default error handling
      };
    }

    startAttendeesTracking() {
      // Initial capture
      this.updateAttendeesList();

      // Set up periodic updates
      this.attendeesUpdateInterval = setInterval(() => {
        this.updateAttendeesList();
      }, CONFIG.INTERVALS.ATTENDEES_UPDATE);
    }

    captureAttendees() {
      try {
        const attendees = new Set(); // Use Set to avoid duplicates

        const processSection = (sectionSelector) => {
          try {
            const button = document.querySelector(sectionSelector);
            const section = button?.closest(CONFIG.SELECTORS.ATTENDEES.SECTION_CONTAINER);

            if (!section) return;

            const nameElements = section.querySelectorAll(CONFIG.SELECTORS.ATTENDEES.NAME_ELEMENT);
            nameElements.forEach((elem) => {
              try {
                const name = elem.textContent?.trim();
                if (!name) return;

                // Skip conference rooms
                if (name.startsWith('‹') && name.endsWith('›')) return;

                // Convert "Last, First" to "First Last"
                const parts = name.split(', ');
                if (parts.length === 2) {
                  attendees.add(`${parts[1]} ${parts[0]}`);
                } else {
                  // Handle cases where name might not be in expected format
                  attendees.add(name);
                }
              } catch (error) {
                Logger.error('Error processing individual attendee:', error);
              }
            });
          } catch (error) {
            Logger.error('Error processing section:', error);
          }
        };

        // Process both Present and Left sections
        processSection(CONFIG.SELECTORS.ATTENDEES.PRESENT_SECTION);
        processSection(CONFIG.SELECTORS.ATTENDEES.LEFT_SECTION);

        return Array.from(attendees).sort().join(CONFIG.STRINGS.ATTENDEES_SEPARATOR);
      } catch (error) {
        Logger.error('Error capturing attendees:', error);
        return ''; // Return empty string on error
      }
    }

    updateAttendeesList() {
      try {
        const newAttendees = this.captureAttendees();

        // Only update if attendees list has changed
        if (newAttendees && newAttendees !== this.lastAttendeesUpdate) {
          this.lastAttendeesUpdate = newAttendees;
          this.currentAttendees = newAttendees;
          Logger.debug('Updated attendees list:', newAttendees);
        }
      } catch (error) {
        Logger.error('Error updating attendees list:', error);
      }
    }

    cleanup() {
      // Add to existing cleanup or create new cleanup method
      if (this.attendeesUpdateInterval) {
        clearInterval(this.attendeesUpdateInterval);
        this.attendeesUpdateInterval = null;
      }
    }

    cleanupDuplicateLines(content) {
      const lines = content.split('\n');
      const cleanedLines = [];
      let lastLine = '';
      let headerSection = true; // Track header section
      let headerCount = 0; // Count header items seen

      for (const line of lines) {
        // Always keep empty lines
        if (!line.trim()) {
          cleanedLines.push(line);
          continue;
        }

        // Check for header lines and always keep them
        if (
          line.startsWith(CONFIG.STRINGS.TITLE_PREFIX) ||
          line.startsWith(CONFIG.STRINGS.MEETING_DATE_PREFIX) ||
          line.startsWith(CONFIG.STRINGS.ATTENDEES_PREFIX) ||
          line === CONFIG.STRINGS.SYSTEM_MESSAGE
        ) {
          cleanedLines.push(line);
          headerCount++;
          // After we've seen all three header items, header section is done
          if (headerCount >= 4) {
            headerSection = false;
          }
          continue;
        }

        // Handle chat messages as is
        if (line.match(CONFIG.REGEX.CHAT_TIMESTAMP)) {
          cleanedLines.push(line);
          headerSection = false;
          continue;
        }

        // For transcript lines (only after header section), apply fuzzy matching
        if (!headerSection) {
          // const currentText = line.substring(line.indexOf(']: ') + 3).trim();
          // const lastText = lastLine.substring(lastLine.indexOf(']: ') + 3).trim();
          const currentText = line.replace(/^[^:]+]:\s*/, '').trim();
          const lastText = lastLine.replace(/^[^:]+]:\s*/, '').trim();

          if (!lastLine || !Utils.fuzzyMatch(currentText, lastText)) {
            cleanedLines.push(line);
            lastLine = line;
          }
        } else {
          // While still in header section, keep everything
          cleanedLines.push(line);
        }
      }

      return cleanedLines.join('\n');
    }
  }

  class UIManager {
    constructor(transcriptManager) {
      this.transcript = transcriptManager;
      this.commentInputVisible = false;
      this.initializeUI();
    }

    initializeUI() {
      this.createButtons();
      this.createSnackbar();
    }

    createButtons() {
      this.copyButton = Utils.createElement('button', {
        textContent: CONFIG.UI.COPY_BUTTON.TEXT,
        style: {
          ...CONFIG.UI.COMMON.BUTTON,
          ...CONFIG.UI.COPY_BUTTON.STYLES,
          backgroundColor: CONFIG.UI.COPY_BUTTON.COLOR,
        },
      });

      this.saveButton = Utils.createElement('button', {
        textContent: CONFIG.UI.SAVE_BUTTON.TEXT,
        style: {
          ...CONFIG.UI.COMMON.BUTTON,
          ...CONFIG.UI.SAVE_BUTTON.STYLES,
          backgroundColor: CONFIG.UI.SAVE_BUTTON.COLOR,
        },
      });

      this.commentButton = Utils.createElement('button', {
        textContent: CONFIG.UI.COMMENT_BUTTON.TEXT,
        style: {
          ...CONFIG.UI.COMMON.BUTTON,
          ...CONFIG.UI.COMMENT_BUTTON.STYLES,
          backgroundColor: CONFIG.UI.COMMENT_BUTTON.COLOR,
        },
      });

      this.commentInput = Utils.createElement('textarea', {
        style: {
          ...CONFIG.UI.COMMENT_INPUT.STYLES,
        },
      });

      this.closeButton = Utils.createElement('button', {
        textContent: CONFIG.UI.CLOSE_BUTTON.TEXT,
        style: {
          ...CONFIG.UI.CLOSE_BUTTON.STYLES, // Don't use COMMON.BUTTON for close
        },
      });

      this.submitButton = Utils.createElement('button', {
        textContent: CONFIG.UI.SUBMIT_BUTTON.TEXT,
        style: {
          color: 'white', // Only take these from COMMON.BUTTON
          border: 'none',
          cursor: 'pointer',
          ...CONFIG.UI.SUBMIT_BUTTON.STYLES,
          backgroundColor: CONFIG.UI.SUBMIT_BUTTON.COLOR,
        },
      });

      this.commentContainer = Utils.createElement('div', {
        style: {
          ...CONFIG.UI.COMMENT_CONTAINER.STYLES,
          display: 'none',
        },
      });

      this.viewButton = Utils.createElement('button', {
        textContent: CONFIG.UI.VIEW_BUTTON.TEXT,
        style: {
          ...CONFIG.UI.COMMON.BUTTON,
          ...CONFIG.UI.VIEW_BUTTON.STYLES,
          backgroundColor: CONFIG.UI.VIEW_BUTTON.COLOR,
        },
      });

      this.mergeToggle = Utils.createElement('button', {
        textContent: CONFIG.UI.MERGE_TOGGLE.TEXT_ON,
        style: {
          ...CONFIG.UI.COMMON.BUTTON,
          ...CONFIG.UI.MERGE_TOGGLE.STYLES,
          backgroundColor: CONFIG.UI.MERGE_TOGGLE.COLOR_ON,
        },
      });

      this.commentContainer.appendChild(this.closeButton);
      this.commentContainer.appendChild(this.commentInput);
      this.commentContainer.appendChild(this.submitButton);

      this.setupButtonListeners();

      document.body.appendChild(this.copyButton);
      document.body.appendChild(this.saveButton);
      document.body.appendChild(this.commentButton);
      document.body.appendChild(this.commentContainer);
      document.body.appendChild(this.viewButton);
      document.body.appendChild(this.mergeToggle);
    }

    setupButtonListeners() {
      this.copyButton.addEventListener('click', () => this.handleCopy());
      this.saveButton.addEventListener('click', () => this.handleSave());
      this.commentButton.addEventListener('click', () => this.toggleCommentInput());
      this.submitButton.addEventListener('click', () => this.handleCommentSubmit());
      this.closeButton.addEventListener('click', () => this.toggleCommentInput());
      this.viewButton.addEventListener('click', () => this.handleViewContent());
      this.commentInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
          this.handleCommentSubmit();
        } else if (e.key === 'Escape') {
          this.toggleCommentInput();
        }
      });
      this.mergeToggle.addEventListener('click', () => this.toggleMerge());
    }

    toggleMerge() {
      this.transcript.mergeEnabled = !this.transcript.mergeEnabled;
      this.mergeToggle.textContent = this.transcript.mergeEnabled
        ? CONFIG.UI.MERGE_TOGGLE.TEXT_ON
        : CONFIG.UI.MERGE_TOGGLE.TEXT_OFF;
      this.mergeToggle.style.backgroundColor = this.transcript.mergeEnabled
        ? CONFIG.UI.MERGE_TOGGLE.COLOR_ON
        : CONFIG.UI.MERGE_TOGGLE.COLOR_OFF;

      // Apply or unapply merging immediately
      if (this.transcript.mergeEnabled) {
        this.transcript.mergeSpeakerSegments();
      } else {
        this.transcript.refreshFromRawSegments();
      }

      this.showSnackbar(
        `Speaker segment merging ${this.transcript.mergeEnabled ? 'enabled' : 'disabled'}`
      );
    }

    handleViewContent() {
      this.commentInputVisible = true;
      this.commentContainer.style.display = 'flex';
      this.commentButton.style.display = 'none';
      this.commentInput.value = this.transcript.getContent(true);
      this.commentInput.scrollTop = this.commentInput.scrollHeight; // Add this line
      this.commentInput.readOnly = true;
      this.submitButton.style.display = 'none';

      const originalColor = this.commentInput.style.backgroundColor;
      this.commentInput.style.backgroundColor = '#444';

      const closeViewHandler = (e) => {
        if (e.type === 'click' || e.key === 'Escape') {
          this.commentInput.readOnly = false;
          this.commentInput.style.backgroundColor = originalColor;
          this.submitButton.style.display = 'flex';
          this.commentInputVisible = false;
          this.commentContainer.style.display = 'none';
          this.commentButton.style.display = 'block';
          this.commentInput.value = '';

          document.removeEventListener('keydown', closeViewHandler);
          this.closeButton.removeEventListener('click', closeViewHandler);
        }
      };

      document.addEventListener('keydown', closeViewHandler);
      this.closeButton.addEventListener('click', closeViewHandler);
    }

    toggleCommentInput() {
      this.commentInputVisible = !this.commentInputVisible;
      this.commentContainer.style.display = this.commentInputVisible ? 'flex' : 'none';
      this.commentButton.style.display = this.commentInputVisible ? 'none' : 'block';

      if (this.commentInputVisible) {
        this.commentInput.value = '';
        this.commentInput.focus();
      } else {
        this.commentInput.value = '';
      }
    }

    handleCommentSubmit() {
      const commentText = this.commentInput.value.trim();
      if (commentText) {
        const timestamp = new Date().toLocaleTimeString('en-US', {
          hour: 'numeric',
          minute: '2-digit',
          hour12: true,
        });

        const formattedComment = `[${timestamp}] - [Injected Comment]: ${commentText}`;
        this.transcript.addEntry(formattedComment);
      }

      this.toggleCommentInput();
    }

    handleCopy() {
      if (this.transcript.history.length === 0) {
        this.showSnackbar(CONFIG.MESSAGES.NO_CONTENT, true);
        return;
      }

      const tempInput = Utils.createElement('textarea', {
        value: this.transcript.getContent(true),
      });
      document.body.appendChild(tempInput);
      tempInput.select();
      document.execCommand('copy');
      document.body.removeChild(tempInput);
      this.showSnackbar(CONFIG.MESSAGES.COPY_SUCCESS);
    }

    handleSave() {
      if (this.transcript.history.length === 0) {
        this.showSnackbar(CONFIG.MESSAGES.NO_CONTENT, true);
        return;
      }

      const blob = new Blob([this.transcript.getContent(true)], { type: CONFIG.FILE.TYPE });
      const fileName = this.transcript.getFileNameId();

      const link = Utils.createElement('a', {
        href: URL.createObjectURL(blob),
        download: `${fileName}.txt`,
      });
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      this.showSnackbar(CONFIG.MESSAGES.SAVE_SUCCESS);
    }

    createSnackbar() {
      this.snackbar = Utils.createElement('div', {
        id: 'snackbar',
        style: CONFIG.STYLES.SNACKBAR,
      });
      document.body.appendChild(this.snackbar);
    }

    showSnackbar(message, isError = false) {
      this.snackbar.textContent = message;
      this.snackbar.style.backgroundColor = isError ? '#d9534f' : '#4CAF50';
      this.snackbar.style.visibility = 'visible';
      this.snackbar.style.opacity = '1';

      setTimeout(() => {
        this.snackbar.style.opacity = '0';
        this.snackbar.style.visibility = 'hidden';
      }, CONFIG.TIMINGS.SNACKBAR_DURATION);
    }

    getTimeDifferenceInSeconds(timeStr1, timeStr2) {
      try {
        // Parse time strings like "6:41 PM"
        const [time1, period1] = timeStr1.split(' ');
        const [hour1, minute1] = time1.split(':').map(Number);
        const [time2, period2] = timeStr2.split(' ');
        const [hour2, minute2] = time2.split(':').map(Number);

        // Convert to 24-hour format
        let hours1 = hour1;
        if (period1 === 'PM' && hour1 < 12) hours1 += 12;
        if (period1 === 'AM' && hour1 === 12) hours1 = 0;

        let hours2 = hour2;
        if (period2 === 'PM' && hour2 < 12) hours2 += 12;
        if (period2 === 'AM' && hour2 === 12) hours2 = 0;

        // Calculate difference in seconds
        const totalSeconds1 = hours1 * 3600 + minute1 * 60;
        const totalSeconds2 = hours2 * 3600 + minute2 * 60;

        return Math.abs(totalSeconds2 - totalSeconds1);
      } catch (error) {
        Logger.error('Error calculating time difference:', error);
        return 0; // Default to no difference on error
      }
    }

    mergeSpeakerSegments() {
      if (!this.mergeEnabled || this.history.length < 2) return;

      // Make a copy of history to work with
      const workingHistory = [...this.history];

      let i = 0;
      while (i < workingHistory.length - 1) {
        // Skip non-transcript entries
        if (workingHistory[i].startsWith('[')) {
          i++;
          continue;
        }

        // Get speaker and time from current entry
        const currentMatch = workingHistory[i].match(/^([^[]+)\s+\[([^\]]+)\]:\s+(.+)$/);
        if (!currentMatch) {
          i++;
          continue;
        }

        const [, currentSpeaker, currentTime, currentText] = currentMatch;

        // Look at next entry
        const nextMatch = workingHistory[i + 1]?.match(/^([^[]+)\s+\[([^\]]+)\]:\s+(.+)$/);
        if (!nextMatch) {
          i++;
          continue;
        }

        const [, nextSpeaker, nextTime, nextText] = nextMatch;

        // Check if same speaker
        if (currentSpeaker === nextSpeaker) {
          // Check time proximity
          const timeDiff = this.getTimeDifferenceInSeconds(currentTime, nextTime);

          // Only merge if time difference is small and entries are likely related
          if (
            timeDiff <= CONFIG.MERGE.TIME_THRESHOLD &&
            this.areEntriesRelated(currentText, nextText)
          ) {
            // Create merged entry with time range
            const mergedText = `${currentText} ${nextText}`;
            const mergedTime = `${currentTime}-${nextTime}`;
            workingHistory[i] = `${currentSpeaker} [${mergedTime}]: ${mergedText}`;

            // Remove the next entry as it's now merged
            workingHistory.splice(i + 1, 1);

            // Don't increment i so we can check if more entries can be merged
          } else {
            // Not mergeable, move to next entry
            i++;
          }
        } else {
          // Different speakers, move to next entry
          i++;
        }
      }

      // Update history with merged entries
      this.history = workingHistory;
    }

    areEntriesRelated(text1, text2) {
      // Short entries are harder to determine relatedness
      if (text1.length < CONFIG.MERGE.MIN_LENGTH || text2.length < CONFIG.MERGE.MIN_LENGTH) {
        return false;
      }

      // If one entry ends with ellipsis or is a sentence fragment, likely related
      if (
        text1.trim().endsWith('...') ||
        !text1.trim().match(/[.!?]$/) ||
        text2.trim().startsWith('...')
      ) {
        return true;
      }

      // If the next part seems to continue the thought
      // Check for common continuation patterns
      const continuePatterns = [
        'and ',
        'but ',
        'so ',
        'because ',
        'which ',
        'that ',
        'also',
        'additionally',
        'furthermore',
        'moreover',
        'however',
        'nevertheless',
        'yet',
        'still',
        'therefore',
        'thus',
        'consequently',
        'as a result',
      ];

      for (const pattern of continuePatterns) {
        if (text2.trim().toLowerCase().startsWith(pattern)) {
          return true;
        }
      }

      // Use fuzzy matching to check relatedness with a lower threshold
      const words1 = text1
        .toLowerCase()
        .split(/\s+/)
        .filter((w) => w.length > 3);
      const words2 = text2
        .toLowerCase()
        .split(/\s+/)
        .filter((w) => w.length > 3);

      // Check for shared words between end and beginning
      const endWords = words1.slice(-3);
      const startWords = words2.slice(0, 3);

      const sharedWords = endWords.filter((w) => startWords.includes(w)).length;

      return sharedWords > 0;
    }
  }

  class DatabaseManager {
    constructor(transcriptManager) {
      this.transcript = transcriptManager;
      this.db = null;
      this.ready = false;
      this.initialize();
    }

    initialize() {
      Logger.info('Initializing DatabaseManager...');
      const request = indexedDB.open(CONFIG.DB.NAME, CONFIG.DB.VERSION);

      request.onupgradeneeded = (event) => {
        Logger.info('Upgrading database...');
        this.db = event.target.result;
        if (!this.db.objectStoreNames.contains(CONFIG.DB.STORE)) {
          this.db.createObjectStore(CONFIG.DB.STORE, { keyPath: 'id' });
          Logger.info('Created store:', CONFIG.DB.STORE);
        }
      };

      request.onsuccess = (event) => {
        this.db = event.target.result;
        this.ready = true;
        Logger.info('Database initialized successfully');
      };

      request.onerror = (event) => {
        Logger.error('Database initialization error:', event.target.error);
        this.ready = false;
      };
    }

    async getLastSession() {
      Logger.info('Getting last session...');
      if (!this.ready || !this.db) {
        Logger.info('Database not ready:', { ready: this.ready, hasDb: !!this.db });
        return null;
      }

      return new Promise((resolve, reject) => {
        try {
          const transaction = this.db.transaction([CONFIG.DB.STORE], 'readonly');
          const store = transaction.objectStore(CONFIG.DB.STORE);
          const request = store.openCursor(null, 'prev');

          request.onsuccess = (event) => {
            const cursor = event.target.result;
            if (cursor) {
              Logger.info('Found last session:', {
                id: cursor.value.id,
                meetingId: cursor.value.meetingId,
                timestamp: new Date(cursor.value.timestamp).toLocaleString(),
              });
              resolve(cursor.value);
            } else {
              Logger.info('No previous session found');
              resolve(null);
            }
          };

          request.onerror = (event) => {
            Logger.error('Error getting last session:', event.target.error);
            resolve(null);
          };
        } catch (error) {
          Logger.error('Error in getLastSession:', error);
          resolve(null);
        }
      });
    }

    async saveSession() {
      if (!this.ready || !this.db || this.transcript.history.length === 0) {
        return;
      }

      const sessionData = {
        id: this.transcript.getSessionId(),
        meetingId: this.transcript.meetingId,
        meetingTitle: this.transcript.meetingTitle,
        organizer: this.transcript.meetingOrganizer,
        content: this.transcript.getContent(),
        timestamp: Date.now(), // creation timestamp
        lastUpdated: Date.now(), // update timestamp
      };

      try {
        const transaction = this.db.transaction([CONFIG.DB.STORE], 'readwrite');
        const store = transaction.objectStore(CONFIG.DB.STORE);

        // Check for existing session
        const getRequest = store.get(sessionData.id);

        getRequest.onsuccess = () => {
          const existingSession = getRequest.result;
          if (existingSession) {
            // Compare content
            const existingLines = existingSession.content.split('\n');
            const newLines = sessionData.content.split('\n');

            if (newLines.length < existingLines.length) {
              Logger.info('Preserving existing content as it contains more lines');

              // Update lastUpdated even when preserving existing content
              existingSession.lastUpdated = Date.now();
              const preserveRequest = store.put(existingSession);
              preserveRequest.onerror = (error) => {
                Logger.error('Error preserving existing session:', error);
                // Attempt cache backup
                cacheManager.saveToCache(existingSession.content);
              };
              return;
            }

            // Keep original creation timestamp
            sessionData.timestamp = existingSession.timestamp;
          }

          // Save the session
          const putRequest = store.put(sessionData);

          putRequest.onsuccess = () => {
            // Only log once on successful save
            // Logger.info('Session saved:', {
            //     id: sessionData.id,
            //     contentLines: sessionData.content.split('\n').length,
            //     lastUpdated: new Date(sessionData.lastUpdated).toLocaleString()
            // });
          };

          putRequest.onerror = (error) => {
            Logger.error('Error saving session:', error);
            // Attempt cache backup on save failure
            cacheManager.saveToCache(sessionData.content);
          };
        };

        getRequest.onerror = (error) => {
          Logger.error('Error checking existing session:', error);
          // Attempt cache backup
          cacheManager.saveToCache(sessionData.content);
        };
      } catch (error) {
        Logger.error('Save operation failed:', error);
        // Attempt cache backup
        cacheManager.saveToCache(sessionData.content);
      }
    }

    async getAllSessions() {
      if (!this.ready || !this.db) return [];

      return new Promise((resolve) => {
        try {
          const transaction = this.db.transaction([CONFIG.DB.STORE], 'readonly');
          const store = transaction.objectStore(CONFIG.DB.STORE);
          const request = store.getAll();

          request.onsuccess = () => {
            resolve(request.result);
          };

          request.onerror = () => {
            Logger.error('Error getting all sessions:', request.error);
            resolve([]);
          };
        } catch (error) {
          Logger.error('Error in getAllSessions:', error);
          resolve([]);
        }
      });
    }

    async cleanupOldSessions() {
      if (!this.ready || !this.db) return;

      try {
        const transaction = this.db.transaction([CONFIG.DB.STORE], 'readwrite');
        const store = transaction.objectStore(CONFIG.DB.STORE);
        const request = store.getAll();

        request.onsuccess = () => {
          const sessions = request.result;
          const now = Date.now();

          sessions.forEach((session) => {
            if (now - session.timestamp > CONFIG.TIMINGS.ONE_DAY_MS) {
              Logger.info('Cleaning up old session:', session.id);
              store.delete(session.id);
            }
          });
        };
      } catch (error) {
        Logger.error('Error during cleanup:', error);
      }
    }

    deleteSession(sessionId) {
      if (!this.ready || !this.db) {
        Logger.info('Cannot delete session - database not ready');
        return;
      }

      try {
        const transaction = this.db.transaction([CONFIG.DB.STORE], 'readwrite');
        const store = transaction.objectStore(CONFIG.DB.STORE);
        const request = store.delete(sessionId);

        request.onsuccess = () => {
          Logger.info('Session deleted successfully:', sessionId);
        };

        request.onerror = (event) => {
          Logger.error('Error deleting session:', event.target.error);
        };
      } catch (error) {
        Logger.error('Delete operation failed:', error);
      }
    }
  }

  // Function declarations first
  const startCapturing = () => {
    if (transcriptManager.captureStarted) return;

    // Ensure title is added before starting capture
    if (!transcriptManager.hasTitleBeenAdded) {
      const currentTitle = transcriptManager.initializeMeetingTitle();
      const { titleFormat, dateFormat } = transcriptManager.formatMeetingDate();
      transcriptManager.addEntry(
        `${CONFIG.STRINGS.TITLE_PREFIX}${titleFormat} - ${currentTitle}\n${CONFIG.STRINGS.MEETING_DATE_PREFIX}${dateFormat}`
      );
      transcriptManager.hasTitleBeenAdded = true;
      Logger.info('Title added successfully');
    }

    transcriptManager.setupContentObservers();
    transcriptManager.captureStarted = true;

    // Start capture immediately
    try {
      transcriptManager.captureLastRow();
      // transcriptManager.captureNewChatMessages();
    } catch (error) {
      Logger.error('Error in initial capture:', error);
    }

    // Start periodic captures
    setInterval(() => {
      try {
        if (!transcriptManager.isResuming) {
          transcriptManager.captureLastRow();
          // transcriptManager.captureNewChatMessages();
        }
      } catch (error) {
        Logger.error('Error in periodic capture:', error);
      }
    }, CONFIG.INTERVALS.CAPTURE);

    // Start periodic saves to IndexedDB (primary storage)
    setInterval(() => {
      try {
        if (dbManager.ready && transcriptManager.history.length > 0) {
          dbManager.saveSession().catch((error) => {
            Logger.error('IndexedDB save failed:', error);
            // On IndexedDB failure, ensure we have a cache backup
            cacheManager.saveToCache(transcriptManager.getContent());
          });
        }
      } catch (error) {
        Logger.error('Error in IndexedDB save:', error);
      }
    }, CONFIG.INTERVALS.DB_SAVE);

    // Backup to cache periodically (secondary storage)
    setInterval(() => {
      try {
        if (transcriptManager.history.length > 0) {
          cacheManager.saveToCache(transcriptManager.getContent());
        }
      } catch (error) {
        Logger.error('Error in cache save:', error);
      }
    }, CONFIG.CACHE.UPDATE_INTERVAL);
  };

  // New function to block until meeting details are retrieved
  const retryUntilMeetingDetailsAvailable = async (retryCount = 0) => {
    const maxRetries = 60; // 60 retries at 1s intervals = 60s max wait
    while (retryCount < maxRetries) {
      await new Promise((resolve) => setTimeout(resolve, 1000)); // Ensures full blocking

      // Actively fetch meeting details instead of just checking meetingId
      await transcriptManager.waitForMeetingDetails();

      if (transcriptManager.meetingId) {
        Logger.info(`Meeting details available, meetingId=${transcriptManager.meetingId}`);
        return true;
      }

      Logger.warn(
        `Meeting details not available yet. Retrying... (${retryCount + 1}/${maxRetries})`
      );
      retryCount++;
    }
    return false; // Failed to retrieve meeting details
  };

  const waitForPageLoad = () => {
    return new Promise((resolve) => {
      if (document.readyState === 'complete') {
        resolve();
      } else {
        window.addEventListener('load', resolve);
        // Fallback timeout
        setTimeout(resolve, 5000);
      }
    });
  };

  const initialize = async () => {
    await waitForPageLoad();

    // Initialize only TranscriptManager first
    transcriptManager = new TranscriptManager();

    // Wait for meeting details before other initializations
    const success = await retryUntilMeetingDetailsAvailable();
    if (!success) {
      Logger.error('Meeting details could not be retrieved after max retries.');
      return;
    }
    Logger.info('Meeting details retrieved, proceeding with session resumption...');

    // Now initialize other managers
    uiManager = new UIManager(transcriptManager);
    dbManager = new DatabaseManager(transcriptManager);
    cacheManager = new CacheManager();

    // Initialize with dependencies
    transcriptManager.initialize(uiManager);

    // Proceed with session check and capture
    const resumed = await transcriptManager.checkForResume();
    if (resumed) {
      Logger.info('Successfully resumed existing session');
    }
    startCapturing();

    // Setup cleanup interval
    setInterval(() => {
      dbManager.cleanupOldSessions();
    }, CONFIG.TIMINGS.ONE_DAY_MS);
  };

  // Start initialization
  setTimeout(initialize, CONFIG.MEETING.CHECK_DELAY);
})();
